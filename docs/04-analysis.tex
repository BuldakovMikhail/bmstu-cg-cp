\chapter{Аналитический раздел}

В данном разделе будет рассмотрена предметная область визуализации облаков.

\section{Модель облаков}
\label{math}
Облака можно представить с помощью оптической модели с рассеиванием и поглощением \cite{partmedia, frostbite, hzd, clouds}.
Оптическая модель описывает как объем излучает, отражает, рассеивает и поглощает свет \cite{rtvg}.
Данная модель может быть описана функцией \eqref{rteint}.
\begin{equation}
	\label{rteint}
	\begin{aligned}
		L(x, \vec{\omega}) =
		\underbrace{\rho(x_0, x) L(x_0, \vec{\omega})}_{L_{ri}(x, \vec{\omega})} + L_m(x, \vec{\omega})
	\end{aligned}
\end{equation}
где $L(x, \vec{\omega})$ --- яркость луча света в точке $x$, излучаемого в направлении~$\vec{\omega}$; $x_0$ --- точка в пространстве откуда был испущен луч света; $\rho(x_1, x_2)$ --- функция, описывающая поглощение луча при распространении его от точки $x_1$ до точки $x_2$. Итоговая яркость луча формируется из двух составляющих: $ L_{ri}(x, \vec{\omega}) $ --- яркости света, формируемой исходным лучом; $ L_m(x, \vec{\omega}) $ --- яркости света, формируемой явлениями внутри среды, например излучением \cite{partmedia}.  

Поскольку распространяющийся в облаках луч подвергается поглощению, рассматривают закон Бугера---Ламберта---Бера \cite{partmedia, rtvg}. Интенсивность светового пучка, обладающего начальной интенсивностью $I_0$, и прошедшего от точки $x_0$ до $x$ внутри облака, вычисляется по формуле \eqref{eq:beers_law_app}.
\begin{equation}
	\label{eq:beers_law_app}
	I = I_0 \cdot e^{-\int_{x_0}^{x} k(u)\,du},
\end{equation}
где $I$ --- итоговая интенсивность пучка, $k(u)$ --- показатель ослабления, а интеграл $ \tau(x_1, x_2) = \int_{x_1}^{x_2} k(u)\,du$ называют оптической толщиной \cite{partmedia, rtvg, hzd, frostbite}.

Коэффициент прозрачности в точке $u$ определяется по формуле \eqref{eq:opacity}.
\begin{equation}
	\label{eq:opacity}
	A_u = 1 - e^{-k(u)}
\end{equation}

Поскольку значение $k(u)$ зависит от плотности вещества, то для того чтобы задать форму облака, необходимо задать распределение плотности в пространстве \cite{partmedia, rtvg, hzd, frostbite}.  


\section{Методы представления облаков}
Методы представления облаков должны определять пространственное распределение плотности облаков на сцене.

Были рассмотрены следующие методы представления облаков:
\begin{itemize}
	\item система частиц;
	\item процедурное;
	\item объемы, ограниченные поверхностью (англ. Surface-Bounded Volumes).
\end{itemize}

\subsection{Система частиц}
\label{particles}
Система частиц --- используемый в компьютерной графике способ представления объектов, не имеющих четких геометрических границ \cite{particles1}. 
Каждая частица в системе задается своим положением в пространстве. Пусть $x$ --- некоторая точка в пространстве, $R$ --- заранее заданный радиус восприимчивости к частицам, $f(x)$ --- функция распределения плотности от расстояния до частицы. Тогда алгоритм определения плотности в точке $x$ будет состоять из следующих шагов.

\begin{enumerate}
	\item Найти все частицы, расстояние до которых от точки $x$ не больше заданного радиуса $R$.
	\item Вычислить расстояния от заданной точки $x$ до отобранных частиц.
	\item Для каждого вычисленного расстояния найти значений функции $f(x)$.
	\item Просуммировать полученные значения функций.
\end{enumerate}

Особенности метода представления:
\begin{itemize}
	\item для определения плотности необходимо выполнить полный перебор;
	\item возможно создавать облака любой формы;
	\item качество результат и количество вычислений зависят от количества частиц.
\end{itemize}

Введение иерархических структур позволяет снизить количество частиц, которые необходимо рассмотреть для отбора требуемых.


\textbf{Воксельные октодеревья}

Октодерево --- древовидная структура данных, в которой у каждого внутреннего узла ровно восемь потомков \cite{octree}.
Каждый узел октодерева задает некоторый объем пространства, а каждый потомок этого узла описывает определенную октанту данного пространства. 
В родительском узле хранятся частицы, попавшие на границы октантов, а в дочернем узле частицы, принадлежащие октанту, который сопоставляется с данным дочерним узлом. Т.~о. для отбора частиц в радиусе $R$ достаточно рассмотреть, только частицы, принадлежащие определенному узлу дерева \cite{clouds}. 

\textbf{Двоичное разбиение пространства}

Двоичное разбиение пространства является методом рекурсивного разбиения пространства на выпуклые множества гиперплоскостями \cite{neighbours}. Каждая гиперплоскость сопоставляется с узлом дерева, что позволяет построить двочиное дерево. Списки частиц хранятся в листьях такого дерева. Выполняя поиск по такому дереву можно найти частицы, которые необходимо рассмотреть для отбора.

\textbf{Иерархия ограничивающих объёмов}

В данном методе группы частиц окружаются оболочками и выстраивается иерархия в виде древовидной структуры данных (двоичное BVH-дерево). По аналогии с двоичным разбиением пространства, для отбора частиц необходимо рассмотреть только те частицы, которые заключены в оболочку, которая сопоставляется с листовым узлом BVH-дерева \cite{clouds}.


\subsection{Объемы, ограниченные поверхностью} 
Облачный объем представляется окружающей его оболочкой, обычно заданной с помощью полигональной сетки. Полигональная сетка --- это совокупность вершин, рeбер и граней, которые определяют форму многогранного объекта в пространстве \cite{mesh}.

Поскольку информация о внутренней структуре облака отсутствует, то предполагается, что объем однородный. Тогда плотность в точке $x$ определяется по следующим шагам \cite{clouds}. 
\begin{enumerate}
	\item Проверить попала ли точка в какой-нибудь из ограниченных, заданных объемов.
	\item Если точка принадлежит объему, то плотность в этой точке, равна заданной плотности объема.
	\item Если точка не принадлежит ни одному объему, то плотность в этой точке равна 0.
\end{enumerate}

Особенности данного метода:
\begin{itemize}
	\item возможно задать облака любой формы;
	\item для определения плотности в точке, необходимо рассмотреть все облака, чтобы понять пересек ли луч одно из них;
	\item предположение, что облака однородны внутри снижает их реалистичность. 
\end{itemize}

\subsection{Процедурное представление} 
\label{implicit}
Распространенным способом представления распределения плотности облаков является использование процедурных методов \cite{frostbite, hzd}. В данном подходе форма облака может задаваться простыми геометрическими объектами, такими как сферы или эллипсоиды, а внутренняя структура с высоким разрешением генерируется процедурно \cite{clouds}. 

Для процедурной генерации могут использоваться функции шума, такие как: шум Перлина, шум Ворлея \cite{frostbite, hzd}. 

\textbf{Шум Перлина} --- это градиентный шум, состоящий из набора псевдослучайных единичных векторов (направлений градиента), расположенных в определенных точках пространства, и, интерполированных функцией сглаживания, значений между этими точками \cite{perlin}.

\textbf{Шум Ворлея} --- это шум полученный инвертированием шума Вороного. Для генерации шума Вороного необходимо создать регулярную сетку некоторого размера и разместить в центре каждой ячейки точку. Далее каждая точка смещается в пределах ячейки случайным образом. Теперь, чтобы рассчитать шум для любого пикселя, нужно определить в какую ячейку он попадает и какие ячейки ему смежны. Далее проходя по всем ячейкам, определяется расстояние между пикселем и смещенными точками, значение шума Вороного --- минимальное из вычисленных расстояний \cite{worley}. 


В итоге, для определения плотности в некоторой точке пространства, необходимо вычислить значение функции шума в данной точке. При этом, можно вычислить значения функции в некотором объеме заранее и хранить эти вычисления в памяти \cite{implicit, hzd, frostbite, clouds}.

\subsection{Сравнение методов представление облаков}

\label{repr_comp}

Сравнение методов будет производится для представления облака параллелепипедной формы, размером $n\times n \times n$ вокселей. Для всех алгоритмов будет рассмотрена худшая ситуация. 

Для задания неоднородного распределения плотности внутри облака предполагается использование частиц с радиусом в пределах одного вокселя, тогда в объеме $n\times n \times n$ будет размещено $n^3$ частиц. Т.~о. для определения плотности в некоторой точке необходимо рассмотреть $n^3$ частиц, а для их хранения необходимо $n^3 \cdot C$ байт памяти, где $C$ --- объем памяти в байтах, занимаемый одной частицей. 

В свою очередь, для объемов ограниченных поверхностью (в качестве поверхности используется полигональная сетка), для того чтобы задать такое же облако необходимо хранить в памяти восемь верши и двенадцать полигонов, а для определения попадания точки в облако необходимо проверить принадлежность этой точки ко всем облакам на сцене, в данном случае, принадлежность одному облаку. Т.~о. плотность в точке вычисляется за одно действие и не зависит от размера облака, а объем занимаемой памяти равен $8\cdot C + 12 \cdot D$, где $C$ --- объем памяти в байтах, занимаемый одной вершиной, а $D$ --- объем памяти, занимаемый одним полигоном.

Для процедурного представления облака, может быть задана также объемлющая оболочка с помощью полигональной сетки, для хранения которой необходимо $8\cdot C + 12 \cdot D$ байт памяти, где $C$ --- объем памяти в байтах, занимаемый одной вершиной, а $D$ --- объем памяти, занимаемый одним полигоном. При этом неоднородность плотности внутри облака, будет задаваться с помощью предварительно процедурно вычисленной текстуры, размер которой $n\times n \times n$, а объем занимаемой памяти $n^3 \cdot E$, где $E$ --- объем памяти в байтах, занимаемый одним вокселем текстуры. Размер текстуры меньше, поскольку она дублируется в пространстве, чтобы занять весь объем. Т.~о. суммарные требования по памяти $8\cdot C + 12 \cdot D + n^3 \cdot E$, а для определения плотности в точке, необходимо определить попала ли точка в облако и получить значение плотности из текстуры, т.~е. так же одно действие. 

В результате, с учетом того, что $D < C < E$. Получаем, что для представления облака заданной формы и размера, большие памяти будет требоваться для представления облака с помощью процедурной генерации, затем с помощью системы частиц и после с помощью объемлющих оболочек. При этом вычисление плотности в точке для процедурной генерации и для объемлющих оболочек одинаково по трудозатратам и меньше, чем для системы частиц.

\subsection*{Вывод}
В результате для решения поставленной задачи был выбран метод процедурного представления, поскольку данный метод позволяет получить плотность в точке пространства за наименьшее количество действий и, в отличии от метода объемлющих оболочек, позволяет учитывать неоднородность внутреннего объема облака.


\section{Анализ методов визуализации облаков}

Для визуализации облаков по их пространственному представлению, необходимо провести вычисление цвета каждого пикселя в буфере кадра. Во всех описанных алгоритмах применятся смешивание цветов. 

Имеется массив из $n$ элементов, содержащий значения цвета и прозрачности в некоторой точке. Тогда смешение цвета вычисляется по формуле \eqref{eq:alpha_blending} итеративно в порядке от последнего к первому, изменяя $i$ от $n-1$ до $0$.
\begin{equation}
	\label{eq:alpha_blending}
	C'_i = C_i + (1 - A_i)C'_{i+1},
\end{equation}
где $C'_i$ --- новое значение цвета, $C_i$ и $A_i$ --- цвет и прозрачность на $i$-м шаге, $C'_{i+1}$ --- значение смешанного цвета на предыдущем шаге. Начальным значением считают $C'_n = 0$.

Формула \eqref{eq:alpha_blending} может быть изменена для прохода по массиву от первого к последнему, т.~е. $i$ от $1$ до $n$.
\begin{equation}
	\label{eq:color_blending_for}
	C'_i = C'_{i - 1} + (1 - A'_{i - 1})C_{i}
\end{equation}
\begin{equation}
	\label{eq:alpha_blending_for}
	A'_i = A'_{i - 1} + (1 - A'_{i - 1})A_{i}
\end{equation}
Начальными значениями в этом случае считают $C'_0 = 0$ и $A'_0=0$ \cite{rtvg}.


\subsection{Алгоритм Сдвиг---Деформации}
\label{slice}

Алгоритм Сдвиг---Деформации состоит из следующих шагов \cite{shearwarp}.

\begin{enumerate}
	\item Сформировать массив срезов объема плоскостями, параллельными оси координат $z$.
	\item Каждый срез из массива сдвинуть перпендикулярно оси $z$, так чтобы луч, распространяющийся в объеме был параллелен оси $z$ (данный шаг называется сдвигом). 
	\item Смешать пиксели текстур срезов в некотором временном буфере, в порядке от последнего к первому.
	\item Спроецировать временный буфер на буфер кадра (данный шаг называется деформацией).
\end{enumerate}

Особенность алгоритма заключается в том, что выбор большого шага среза приведет к меньшему количеству вычислений, но при этом возможна потеря резких форм облака.


\subsection{Разбрызгивание текстур}
\label{splatting}
Алгоритм разбрызгивания текстур применяется для визуализации системы частиц, но в общем случае, под частицой, в данном контексте, подразумевается точка пространства с заданной плотностью \cite{clouds}.
Частицы могут быть визуализированы с помощью текстурированного четырехугольника, представляющего проекцию частицы на плоскость, также называемую <<пятном>> или <<отпечатком>> (от англ. splat и footprint соответственно) \cite{clouds, voxel}. 

Алгоритм разбрызгивания состоит из следующих шагов, применяемых к каждому пикселю буфера кадра \cite{voxel, clouds}.
\begin{enumerate}
	\item Найти частицы, пересекаемые лучом, исходящим от наблюдателя и приходящим в некоторый пиксель буфера кадра.
	\item Смешать проекции текстур этих частиц в буфере кадра, в порядке возрастания расстояния от наблюдателя.
\end{enumerate} 

Особенность алгоритма состоит в том, что необходимо найти частицы, отпечаток которых попадает на выбранный пиксель и при этом хранить такие частицы нужно будет в порядке возрастания удаленности от наблюдателя.

\subsection{Ray Marching}
\label{ray}

Алгоритм Ray Marching состоит из следующих шагов \cite{hzd, frostbite, clouds}.
\begin{enumerate}
	\item Для каждого пикселя буфера выпускается луч от наблюдателя.
	\item Разбить луч на равные интервалы.
	\item Выполнить итеративное смешение цветов на этих интервалах.
\end{enumerate}

Особенность алгоритма заключается в том, что за счет итеративного смешивания цветов нет необходимости в сохранении порядка интервалов, а итоговый цвет можно вычислять по ходу распространения луча.

\section{Сравнение алгоритмов визуализации}

Сравнение алгоритмов будет проводится для облака, описанного в пункте \ref{repr_comp}. Сравнение производится по худшему случаю.

Для алгоритма сдвиг деформации важен выбор шага, который влияет на точность визуализации. В дальнейшем будет считаться, что шаг среза равен одному. Тогда для данного алгоритма необходимо будет сформировать $n$ срезов размера $n \times n$ и один дополнительный буфер размера $n \times n$, для хранения которых требуется $(n + 1)\cdot(n^2 \cdot A)$, где $A$ --- объем памяти, занимаемый одной ячейкой среза. Для сдвига необходимо изменить координаты каждого пикселя в каждом срезе, т.~о. необходимо выполнить порядка $n \cdot n^2$ операций \cite{shearwarp}. После сдвига производится смешивание текстур во временном буфере, т.~е. производится еще порядка $n \cdot n^2$ операций и далее полученный буфер проецируется на буфер кадра за порядка $n^2$ операций. В итоге для визуализации одного облака алгоритмом Сдвиг---Деформации необходимо порядка $O(n^3)$ операций.

В алгоритме разбрызгивания текстур, будет считаться, что каждый луч, испущенный наблюдателем, пересек $n$ частиц. Тогда для каждого луча требуется дополнительно $n\cdot B$ байт памяти, где $B$ --- объем памяти в байтах, занимаемый одной частицей. 
В итоге, для каждого пикселя буфера кадра вычисляются проекции частиц, т.~о. для визуализации облака необходимо выполнить порядка $N\cdot M \cdot n \cdot \alpha$ операций, где размер буфера кадра $N \times M$, $\alpha$ --- количество операций, требуемое для определения текстур частиц, которые пересекаются с лучом наблюдателя. $\alpha$ зависит от способа представления частиц, в худшем случае, эта операция требует полного просмотра частиц, т.~е. в худшем случае визуализация выполняется за порядка $N\cdot M \cdot n \cdot n^3$ операций. 

В алгоритме Ray Marching, испущенный луч хранит результирующий цвет некоторого пикселя в буфере кадра, т.~е. требуется $D$ байт памяти, где $D$ --- объем памяти, требуемый для хранения цвета. Для визуализации облака требуется порядка $N \cdot M \cdot \beta$ операций, где размер буфера кадра $N \times M$, $\beta$ --- количество операций, требуемое для определения цвета в некоторой точке луча. В худшем случае, если для представления облаков используется система частиц, то визуализация выполняется за порядка $N \cdot M \cdot n^2$ операций.

В результате, поскольку обычно размеры буфера кадра велики, то минимальное количество операций необходимо для алгоритма Сдвиг---Деформации, затем для алгоритма Ray Marching, и больше всего операций требуется для визуализации облака с помощью системы частиц. При этом алгоритм Ray Marching требует меньше памяти, чем алгоритм Сдвиг---Деформации.

\subsection*{Вывод}
В результате для визуализации облаков был выбран алгоритм Ray Marching, поскольку данный алгоритм требует меньше всего памяти и при этом обладает приемлемой оценкой количества операций.

\section{Модель освещения}

Поскольку солнце сильно удалено от Земли, то лучи распространяются параллельно, т.~е. угол падения света считается одинаковым для всех точек пространства в пределах сцены.

Световая энергия луча, распространяющегося в облачном объеме, может быть поглощена или отражена некоторой частицей. При этом облака являются анизатропной средой, т.~е. отраженные фотоны распространяются в разных направлениях неравномерно \cite{clouds, partmedia, hzd, frostbite}.

Закон Бугера---Ламберта---Бера \eqref{eq:beers_law_app} описывает явление затухания луча при его распространении в облаках, приближенно интеграл будет рассчитываться как сумма, тогда закон можно записать следующим образом \eqref{eq:bl}.
\begin{equation}
	\label{eq:bl}
	BL = e ^ {-d}
\end{equation}
где $ d $ --- накопленная оптическая толщина.


Для аппроксимации явления неравномерного распространения отраженного света используют фазовую функцию \cite{partmedia, hzd, frostbite, clouds}.
Фазовая функция описывает вероятность отражения фотона от рассеивающего объекта под определенным углом. 
В качестве фазовой функции для облаков используется функция Хеньи --- Гринштейна \eqref{eq:hg}.  
\begin{equation}
	\label{eq:hg}
	p(\theta) = \frac{1}{4\pi} \frac{1 - g^2}{(1 + g^2 - 2g\cos \theta)^{3/2}},
\end{equation}
где $ g $ --- варьируемый параметр, причем $ -1 \leq g \leq 1 $, а $\theta$ --- угол между падающим и отраженным лучами \cite{clouds}.


Из распределения отраженного света фазовой функцией видно, что луч, после отражения будет распространяться вероятнее всего в направлении близком к исходному. 
Таким образом, чтобы направление луча изменилось на 180 градусов необходим достаточно длинный путь внутри облака, что приводит к большой накопленной плотности, в результате чего по формуле \ref{eq:bl} энергия луча будет близка к нулю. 
В результате чего, наблюдатель, выпускающий луч в направлении близком к направлению падения света, будет видеть нереалистично темные облака \cite{hzd}. Для того чтобы этого не происходило вводится поправка по формуле \eqref{eq:sugar_powder}.

\begin{equation}
	\label{eq:sugar_powder}
	PSE = 1 - e ^ {-2 d}
\end{equation}

Для расчета энергии луча, испущенного солнцем, в некоторой точке пространства, необходимо учесть путь этого луча внутри облака до рассматриваемой точки.
Для этого накопленная оптическая толщина $d$, вычисляется на нескольких точках, выбранных на луче.
В итоге, энергия света, в некоторой точке пространства вычисляется по формуле \eqref{eq:light_model}.
\begin{equation}
	\label{eq:light_model}
	E = 2 \cdot e ^ {-d} \cdot (1 - 2 e ^ {-2d}) \cdot \frac{1}{4\pi} \frac{1 - g^2}{(1 + g^2 - 2g\cos \theta)^{3/2}}
\end{equation}
где $ g $ --- некоторая константа в функции Хеньи-Гринштейна, а $ \theta $ --- угол между лучами взгляда и падения света.

\section{Постановка задачи}

\includeimage
{level0} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{h} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Диграмма IDEF0 постановки задачи нулевого уровня} % Подпись рисунка



\section*{Вывод}

В данном разделе был проведен анализ способов представления облаков, методов визуализации и модели освещения, которые возможно использовать для решения поставленных задач. В итоге была выбрана связка из процедурного представления облаков с алгоритмом Ray Marching.

В таблицах \ref{tbl:repr_choice} и \ref{tbl:rend_choice} представлено сравнение методов представления облаков и алгоритмов визуализации. По каждому параметру составлен рейтинг: 1 --- лучший способ, 3 --- худший.

\begin{table}[h]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{Сравнение методов представления облаков}
			\label{tbl:repr_choice}
			\begin{tabular}{|c|c|c|c|}
				\hline
				Характеристика &  СЧ  & ООП & П \\
				\hline
				Учет неоднородности &  Да  & Нет & Да \\
				\hline
				Трудоемкость вычисления плотности в точке &  2  & 1 & 1 \\
				\hline
				Требования по памяти & 2 & 1 & 3 \\
				\hline
			\end{tabular}
			\begin{tablenotes}
				\small
				\item Примечание: СЧ --- система частиц; ООП --- объемы, ограниченные поверхностью; П --- процедурное представление, с предварительно вычисленными значениями функций шума.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}

\begin{table}[h]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{Сравнение алгоритмов визуализации облаков}
			\label{tbl:rend_choice}
			\begin{tabular}{|c|c|c|c|}
				\hline
				Характеристика &  СД  & РТ & RM \\
				\hline
				Трудоемкость построения изображения &  1  & 3 & 2 \\
				\hline
				Требования по памяти & 3 & 2 & 1 \\
				\hline
			\end{tabular}
			\begin{tablenotes}
				\small
				\item Примечание:  СД --- алгоритм сдвиг---деформации; РТ --- алгоритм разбрызгивания текстур; RM --- алгоритм Ray Marching.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}



