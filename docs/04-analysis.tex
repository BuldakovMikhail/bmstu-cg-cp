\chapter{Аналитический раздел}

В данном разделе будет рассмотрена предметная область визуализации облаков.

\section{Модель облаков}
\label{math}
Облака представляют с помощью оптической модели, которая описывает как облачный объем рассеивает и поглощает свет~\cite{partmedia, frostbite, hzd, clouds, rtvg}.
Данная модель может быть описана функцией~\eqref{rteint}.
\begin{equation}
	\label{rteint}
	\begin{aligned}
		L(x, \vec{\omega}) = \rho(x_0, x) L(x_0, \vec{\omega}) + L_m(x, \vec{\omega}),
	\end{aligned}
\end{equation}
где $L(x, \vec{\omega})$ --- яркость луча света в точке $x$, излучаемого в направлении~$\vec{\omega}$; $x_0$ --- точка в пространстве откуда был испущен луч света; $\rho(x_1, x_2)$ --- функция, описывающая ослабление света при распространении его от точки $x_1$ до точки $x_2$. Итоговая яркость луча формируется из двух составляющих: $ L_{ri}(x, \vec{\omega}) = \rho(x_0, x) L(x_0, \vec{\omega})$ --- яркости света, формируемой исходным лучом; $ L_m(x, \vec{\omega}) $ --- яркости света, формируемой явлениями внутри среды~\cite{partmedia}.  

Ослабление света за счет поглощения и рассеивания внутри облака описывается законом Бугера---Ламберта---Бера~\mbox{\cite{partmedia, rtvg}}. Интенсивность светового пучка, обладающего начальной интенсивностью $I_0$, и прошедшего от точки $x_0$ до $x$ внутри облака, вычисляется по формуле~\eqref{eq:beers_law_app}.
\begin{equation}
	\label{eq:beers_law_app}
	I = I_0 \cdot e^{-\int_{x_0}^{x} k(u)\,du},
\end{equation}
где $I$ --- итоговая интенсивность пучка, а $k(u)$ называют показателем ослабления, который различен для разных длин волн света~\cite{partmedia, rtvg, hzd, frostbite}.


Для определения доли светового потока, которая прошла без изменения направления через облачный объем используют понятие прозрачности~\mbox{\cite{rtvg, hzd, frostbite}}.
Прозрачность в точке $u$ определяется по формуле~\eqref{eq:opacity}.
\begin{equation}
	\label{eq:opacity}
	A_u = 1 - e^{-k(u)}.
\end{equation}

Поскольку значение $k(u)$ зависит от плотности вещества из которого состоят облака, то для того чтобы задать форму облака, достаточно задать распределение плотности вещества в пространстве~\cite{partmedia, rtvg, hzd, frostbite}.  


\section{Методы представления облаков}

Были рассмотрены следующие методы представления плотности облаков:
\begin{itemize}
	\item система частиц;
	\item объемы, ограниченные поверхностью;
	\item процедурное представление.
\end{itemize}

\subsection{Система частиц}
\label{particles}
Система частиц --- способ представления объектов с помощью набора частиц~\cite{particles1}. 
Каждая частица в системе задается своим положением в пространстве. Если $x$ --- некоторая точка в пространстве, $R$ --- заранее заданный радиус восприимчивости к частицам, $f(x)$ --- функция распределения плотности от расстояния до частицы. Тогда алгоритм определения плотности в точке $x$ будет состоять из следующих шагов:
\begin{enumerate}
	\item найти все частицы, расстояние до которых от точки $x$ не больше заданного радиуса $R$;
	\item вычислить расстояния от заданной точки $x$ до отобранных частиц;
	\item для каждого вычисленного расстояния найти значения функции $f(x)$;
	\item просуммировать полученные значения функции.
\end{enumerate}

Особенности метода представления:
\begin{itemize}
	\item для определения плотности необходимо выполнить полный перебор;
	\item возможно представлять облака любой формы;
	\item качество результата и количество вычислений зависят от количества частиц.
\end{itemize}


\subsection{Объемы, ограниченные поверхностью} 
Облачный объем представляется окружающей его оболочкой, обычно заданной с помощью полигональной сетки. Полигональная сетка --- это совокупность вершин, рeбер и граней, которые определяют форму многогранного объекта в пространстве~\cite{mesh}.

Поскольку информация о внутренней структуре облака отсутствует, то предполагается, что объем однородный. Тогда плотность в точке $x$ определяется по следующим шагам~\cite{clouds}: 
\begin{enumerate}
	\item проверить попала ли точка в какой-нибудь из ограниченных, заданных объемов;
	\item если точка принадлежит объему, то плотность в этой точке равна заданной плотности объема, иначе плотность в этой точке равна 0.
\end{enumerate}

Особенности данного метода:
\begin{itemize}
	\item возможно задать облака любой формы;
	\item для определения плотности в точке, необходимо рассмотреть все облака, чтобы понять попала ли точка в одно из них;
	\item предположение, что облака однородны внутри снижает их реалистичность. 
\end{itemize}


\subsection{Процедурное представление} 
\label{implicit}
Для процедурной генерации могут использоваться функции шума, такие как: шум Перлина, шум Ворлея~\cite{frostbite, hzd}. 

\textbf{Шум Перлина}

Шум Перлина --- это градиентный шум, состоящий из набора псевдослучайных единичных векторов (направлений градиента), расположенных в определенных точках пространства, и, интерполированных функцией сглаживания, значений между этими точками~\cite{perlin}.

\textbf{Шум Ворлея}

Шум Ворлея --- это шум полученный инвертированием шума Вороного~\cite{worley}. Генерация шума Вороного состоит из следующих шагов:
\begin{enumerate}
	\item создать регулярную сетку некоторого размера;
	\item разместить в центре каждой ячейки точку;
	\item сместить случайным образом каждую точку в пределах своей ячейки.
\end{enumerate}
Вычисление значения шума Вороного в точке $x$ состоит из следующих шагов:
\begin{enumerate}
	\item определить в какую ячейку попала точка $x$;
	\item найти смежные ячейки с данной;
	\item определить расстояние от точки $x$ до всех точек, ассоциированных со смежными ячейками;
	\item вернуть минимальное из вычисленных расстояний.
\end{enumerate}

В данном подходе форма облака может задаваться поверхностью, а внутренняя структура с высоким разрешением генерируется процедурно~\mbox{\cite{implicit, hzd, frostbite, clouds}}. 

В итоге, определение плотности в точке состоит из следующих шагов:
 \begin{enumerate}
	\item определить попала ли точка в объем, содержащий облако;
	\item если точка попала в объем, то плотность равна значению функции шума, иначе плотность равна 0.
\end{enumerate}

Особенности данного представления:
\begin{itemize}
	\item возможно задать облака любой формы;
	\item для определения плотности в точке, необходимо рассмотреть все облака, чтобы понять попала ли точка в одно из них;
	\item возможно вычислить значения функций шума заранее и хранить их в некотором массиве. 
\end{itemize}


\subsection{Сравнение методов представление облаков}

\label{repr_comp}

Сравнение методов будет производится для представления облака кубической формы, размером $n\times n \times n$ вокселей. Для всех алгоритмов будут рассмотрены худшие случаи. 

Для задания неоднородного распределения плотности внутри облака предполагается использование частиц с радиусом в пределах одного вокселя, тогда в объеме $n\times n \times n$ будет размещено $n^3$ частиц. Т.~о. для определения плотности в некоторой точке необходимо рассмотреть $n^3$ частиц, а для их хранения требуется $n^3 \cdot C$ байт памяти, где $C$ --- объем памяти в байтах, занимаемый одной частицей. 

В свою очередь, для объемов ограниченных поверхностью (в качестве поверхности используется полигональная сетка), для того чтобы задать такое же облако требуется хранить в памяти восемь вершин и двенадцать полигонов, а для определения попадания точки в облако необходимо проверить принадлежность этой точки ко всем облакам на сцене, в данном случае, принадлежность одному облаку. Т.~о. плотность в точке вычисляется за одно действие и не зависит от размеров облака, а объем требуемой памяти равен $8\cdot C + 12 \cdot D$, где $C$ --- объем памяти в байтах, занимаемый одной вершиной, а $D$ --- объем памяти, занимаемый одним полигоном.

Для процедурного представления облака, может быть задана также объемлющая оболочка с помощью полигональной сетки, для хранения которой требуется $8\cdot C + 12 \cdot D$ байт памяти, где $C$ --- объем памяти в байтах, занимаемый одной вершиной, а $D$ --- объем памяти, занимаемый одним полигоном. При этом неоднородность плотности внутри облака, будет задаваться с помощью процедурно вычисленной текстуры, размер которой $n\times n \times n$, а объем требуемой памяти $n^3 \cdot E$, где $E$ --- объем памяти в байтах, занимаемый одним вокселем текстуры. Т.~о. суммарные требования по памяти $8\cdot C + 12 \cdot D + n^3 \cdot E$, а для определения плотности в точке, необходимо определить попала ли точка в облако и получить значение плотности из текстуры, т.~е. выполнить два действия. 

В результате, с учетом того, что $D < C < E$. Получаем, что для представления облака заданной формы и размера, больше памяти будет требоваться для представления облака с помощью процедурной генерации, затем с помощью системы частиц и после с помощью объемлющих оболочек. При этом вычисление плотности в точке для процедурной генерации и для объемлющих оболочек приблизительно одинаково по трудозатратам и меньше, чем для системы частиц.

\subsection*{Вывод}
В результате для решения поставленной задачи был выбран метод процедурного представления, поскольку данный метод позволяет получить плотность в точке пространства за наименьшее количество действий и, в отличии от метода объемлющих оболочек, позволяет учитывать неоднородность внутреннего объема облака.


\section{Алгоритмы визуализации облаков}

Для визуализации облаков по их пространственному представлению, необходимо провести вычисление цвета каждого пикселя в буфере кадра. 
Буфер кадра --- часть графической памяти для хранения массива кодов, определяющих засветку пикселей на экране~\cite{framebuffer}. 

Были рассмотрены следующие алгоритмы визуализации облаков:
\begin{itemize}
	\item Сдвиг---Деформации;
	\item разбрызгивание текстур;
	\item Ray Marching.
\end{itemize}

Во всех описанных алгоритмах цвет пикселя вычисляется с помощью смешивания цветов. 

Имеется массив из $n$ элементов, содержащий значения цвета и прозрачности в некоторой точке. Тогда смешивание цвета вычисляется по формуле~\eqref{eq:alpha_blending} итеративно в порядке от последнего к первому элементу, изменяя $i$ от $n-1$ до $0$.
\begin{equation}
	\label{eq:alpha_blending}
	C'_i = C_i + (1 - A_i)C'_{i+1},
\end{equation}
где $C'_i$ --- новое значение цвета, $C_i$ и $A_i$ --- цвет и прозрачность на $i$-м шаге, $C'_{i+1}$ --- значение смешанного цвета на предыдущем шаге. Начальным значением считают $C'_n = 0$.

Формула~\eqref{eq:alpha_blending} может быть изменена для прохода по массиву от первого к последнему, т.~е. $i$ от $1$ до $n$.
\begin{equation}
	\label{eq:color_blending_for}
	C'_i = C'_{i - 1} + (1 - A'_{i - 1})C_{i},
\end{equation}
\begin{equation}
	\label{eq:alpha_blending_for}
	A'_i = A'_{i - 1} + (1 - A'_{i - 1})A_{i}.
\end{equation}
Начальными значениями в этом случае считают $C'_0 = 0$ и $A'_0=0$~\cite{rtvg}.



\subsection{Алгоритм Сдвиг---Деформации}
\label{slice}

Алгоритм Сдвиг---Деформации состоит из следующих шагов~\cite{shearwarp}:
\begin{enumerate}
	\item сформировать массив срезов объема плоскостями, параллельными оси координат $z$;
	\item каждый срез из массива сдвинуть перпендикулярно оси $z$, так чтобы луч, распространяющийся в объеме был параллелен оси $z$ (данный шаг называется сдвигом); 
	\item смешать пиксели текстур срезов в некотором временном буфере, в порядке от последнего к первому;
	\item спроецировать временный буфер на буфер кадра (данный шаг называется деформацией).
\end{enumerate}

Особенность алгоритма заключается в том, что выбор большого шага среза приведет к меньшему количеству вычислений, но при этом возможна потеря резких форм облака.


\subsection{Алгоритм разбрызгивания текстур}
\label{splatting}
Алгоритм разбрызгивания текстур применяется для визуализации системы частиц, но в общем случае, под частицой, в данном контексте, подразумевается точка пространства с заданной плотностью~\cite{clouds}.
Частицы могут быть визуализированы с помощью текстурированного четырехугольника, представляющего проекцию частицы на плоскость, также называемую <<отпечатком>>~\mbox{\cite{clouds, voxel}}. 

Алгоритм разбрызгивания состоит из следующих шагов~\mbox{\cite{voxel, clouds}}:
\begin{enumerate}
	\item найти частицы, пересекаемые лучом, исходящим от наблюдателя и приходящим в некоторый пиксель буфера кадра;
	\item смешать проекции текстур этих частиц в буфере кадра, в порядке удаления от наблюдателя.
\end{enumerate} 

Особенность алгоритма состоит в том, что необходимо найти частицы, отпечаток которых попадает на выбранный пиксель и при этом хранить такие частицы нужно будет в порядке удаления от наблюдателя.

\subsection{Алгоритм Ray Marching}
\label{ray}

Алгоритм Ray Marching состоит из следующих шагов~\cite{hzd, frostbite, clouds}:
\begin{enumerate}
	\item выпустить от наблюдателя луч для каждого пикселя буфера кадра;
	\item разбить луч на равные интервалы;
	\item выполнить итеративное смешение цветов на этих интервалах.
\end{enumerate}

Особенность алгоритма заключается в том, что за счет итеративного смешивания цветов нет необходимости в сохранении порядка интервалов, а итоговый цвет можно вычислять по ходу распространения луча.

\subsection{Сравнение алгоритмов визуализации}

Сравнение алгоритмов будет проводится для облака, описанного в пункте~\ref{repr_comp}. Сравнение производится для худшего случая.

Для алгоритма сдвиг деформации важен выбор шага, который влияет на точность визуализации. В дальнейшем будет считаться, что шаг среза равен одному. Тогда для данного алгоритма необходимо будет сформировать $n$ срезов размера $n \times n$ и один дополнительный буфер размера $n \times n$, для хранения которых требуется $(n + 1)\cdot(n^2 \cdot A)$, где $A$ --- объем памяти, занимаемый одной ячейкой среза. Для сдвига необходимо изменить координаты каждого пикселя в каждом срезе, т.~о. необходимо выполнить порядка $n \cdot n^2$ операций~\cite{shearwarp}. После сдвига производится смешивание текстур во временном буфере, т.~е. производится еще порядка $n \cdot n^2$ операций и далее полученный буфер проецируется на буфер кадра за порядка $n^2$ операций. В итоге для визуализации одного облака алгоритмом Сдвиг---Деформации необходимо порядка $O(n^3)$ операций.

В алгоритме разбрызгивания текстур, будет считаться, что каждый луч, испущенный наблюдателем, пересек $n$ частиц. Тогда для каждого луча требуется дополнительно $n\cdot B$ байт памяти, где $B$ --- объем памяти в байтах, занимаемый одной частицей. 
В итоге, для каждого пикселя буфера кадра вычисляются проекции частиц, т.~о. для визуализации облака необходимо выполнить порядка $N\cdot M \cdot n \cdot \alpha$ операций, где размер буфера кадра $N \times M$, $\alpha$ --- количество операций, требуемое для определения текстур частиц, которые пересекаются с лучом наблюдателя. Т.~о. визуализация выполняется за порядка $O(NMn)$ операций. 

В алгоритме Ray Marching, испущенный луч хранит результирующий цвет некоторого пикселя в буфере кадра, т.~е. требуется $D$ байт памяти, где $D$ --- объем памяти, требуемый для хранения цвета. Для визуализации облака требуется порядка $N \cdot M \cdot \beta \cdot \gamma$ операций, где размер буфера кадра $N \times M$, $\beta$ --- количество операций, требуемое для определения цвета в некоторой точке луча, а $\gamma$ --- константа, которая обозначает количество интервалов на которые разбивается луч. Т.~о. визуализация выполняется за порядка $O(NM)$ операций.

В результате, поскольку обычно размеры буфера кадра велики, то минимальное количество операций необходимо для алгоритма Сдвиг---Деформации, затем для алгоритма Ray Marching, и больше всего операций требуется для визуализации облака с помощью системы частиц. При этом алгоритм Ray Marching требует меньше памяти, чем алгоритм Сдвиг---Деформации.

\subsection*{Вывод}
В результате для визуализации облаков был выбран алгоритм Ray Marching, поскольку данный алгоритм требует меньше всего памяти и при этом обладает приемлемой оценкой количества операций.

\section{Модель освещения}

Поскольку облака освещаются солнцем, которое сильно удалено от Земли, то солнечные лучи распространяются параллельно.

Световая энергия луча, распространяющегося в облачном объеме, может быть поглощена или рассеяна некоторой частицей. При этом облака являются анизатропной средой, т.~е. отраженные фотоны распространяются в разных направлениях неравномерно~\cite{clouds, partmedia, hzd, frostbite}.

Модель освещения приближенно учитывает формулу~\eqref{eq:beers_law_app}, которая рассчитывается следующим образом~\eqref{eq:bl}.
\begin{equation}
	\label{eq:bl}
	BL = e ^ {-d},
\end{equation}
где $ d $ --- приближенно вычисленное значение интеграла $\int_{x_0}^{x} k(u)\,du$.

Для аппроксимации явления неравномерного распространения рассеянного света используют фазовую функцию~\cite{partmedia, hzd, frostbite, clouds}.
Фазовая функция описывает вероятность отражения луча от рассеивающего объекта под определенным углом. 
В качестве фазовой функции для облаков используется функция Хеньи --- Гринштейна~\eqref{eq:hg}.  
\begin{equation}
	\label{eq:hg}
	p(\theta) = \frac{1}{4\pi} \frac{1 - g^2}{(1 + g^2 - 2g\cos \theta)^{3/2}},
\end{equation}
где $ g $ --- варьируемый параметр, причем $ 0 \leq g < 1 $, а $\theta$ --- угол между направлениями луча до и после отражения~\cite{clouds}.

В результате рассеивания луч может изменить свое направление на 180 градусов.
Для учета этого в модель освещения вносят поправку~\mbox{\cite{hzd, frostbite}}. Поправка вычисляется по формуле~\eqref{eq:sugar_powder}.

\begin{equation}
	\label{eq:sugar_powder}
	PSE = 1 - e ^ {-2 d}.
\end{equation}

Для расчета энергии луча, испущенного солнцем, в некоторой точке пространства, необходимо учесть путь этого луча внутри облака до рассматриваемой точки.
Для этого плотность вычисляется в нескольких точках, выбранных на луче.

В итоге, яркость света, в некоторой точке пространства вычисляется по формуле~\eqref{eq:light_model}.
\begin{equation}
	\label{eq:light_model}
	L = 2 \cdot e ^ {-d} \cdot (1 - 2 e ^ {-2d}) \cdot \frac{1}{4\pi} \frac{1 - g^2}{(1 + g^2 - 2g\cos \theta)^{3/2}},
\end{equation}
где $ g $ --- некоторая константа в функции Хеньи---Гринштейна, а $ \theta $ --- угол между лучами света и направления взгляда.

\section{Расчет цвета неба}

В случае, когда на небе нет облаков, яркость в точке пространства $x$ вычисляется приближено по формуле~\eqref{eq:sky}.
\begin{equation}
	\label{eq:sky}
	L = P(cos(\theta))  \cdot \beta_0 \cdot e^{-\beta_0 (d_1 + d_2) - \frac{h}{H_0}},
\end{equation}
где $P(cos(\theta))$ --- коэффициент зависящий от типа рассеивания; $\theta$ --- угол между лучами света и направления взгляда; $\beta_0$ --- некоторая константа; $h$ --- высота в текущей точке пространства; $H_0$ --- масштабирующая высота; $d_1$ --- суммарная плотность воздуха, накопленная лучом распространяющимся от наблюдателя до точки $x$; $d_2$ --- суммарная плотность воздуха, накопленная лучом распространяющимся от солнца к точке $x$~\cite{frostbite}.

Проходя через атмосферу луч подвергается двум типам рассеивания: Рэлеевскому 
рассеиванию и рассеиванию Ми~\cite{frostbite}. 


Коэффициент Рэлеевского рассеивания вычисляется по формуле~\eqref{eq:reileight}.
\begin{equation}
		\label{eq:reileight}
		P_R(\cos(\theta)) = \frac{3\pi}{16}(1 + \cos(\theta)).
\end{equation}


Коэффициент рассеивания Ми вычисляется по формуле~\eqref{eq:mie}.
\begin{equation}
	\label{eq:mie}
	P_M(\cos(\theta)) = \frac{3\pi}{8}\frac{g^2 (1 + \cos(\theta)^2)}{(2 + g^2)(1+ g^2 - 2g \cos(\theta))^{\frac{3}{2}}},
\end{equation}
где $ g $ --- варьируемый параметр, причем $ 0 \leq g < 1 $.

\section{Постановка задачи}

Постановка задачи может быть представлена с помощью диаграммы, изображенной на рисунке~\ref{img:level0}.

\includeimage
{level0} % Имя файла без расширения (файл должен быть расположен в директории inc/img/)
{f} % Обтекание (без обтекания)
{H} % Положение рисунка (см. figure из пакета float)
{1\textwidth} % Ширина рисунка
{Диграмма IDEF0 нулевого уровня} % Подпись рисунка



\section*{Вывод}

В данном разделе был проведен анализ методов представления облаков, алгоритмов визуализации и модели освещения, которые возможно использовать для решения поставленных задач. В итоге были выбраны процедурное представление облаков и алгоритм Ray Marching.

В таблицах~\ref{tbl:repr_choice} и~\ref{tbl:rend_choice} представлено сравнение методов представления облаков и алгоритмов визуализации.

\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{Сравнение методов представления облаков}
			\label{tbl:repr_choice}
			\begin{tabular}{|c|c|c|c|}
				\hline
				Характеристика &  СЧ  & ООП & П \\
				\hline
				Учет неоднородности &  Да  & Нет & Да \\
				\hline
				Трудоемкость вычисления плотности в точке &  $O(n^3)$ & $O(Q)$ & $O(Q)$ \\
				\hline
				Требования по памяти &  $O(n^3)$ & $O(Q)$ & $O(Q + n^3)$ \\
				\hline
			\end{tabular}
			\begin{tablenotes}
				\small
				\item Примечание: СЧ --- система частиц; ООП --- объемы, ограниченные поверхностью; П~--- процедурное представление, с предварительно вычисленными значениями функций шума; $n$ --- размер облака; $Q$ --- количество ограничивающих поверхностей.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}

\begin{table}[H]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{Сравнение алгоритмов визуализации облаков}
			\label{tbl:rend_choice}
			\begin{tabular}{|c|c|c|c|}
				\hline
				Характеристика &  СД  & РТ & RM \\
				\hline
				Трудоемкость построения изображения &  $O(n^3)$  & $O(NMn)$ & $O(NM)$ \\
				\hline
				Требования по памяти & $O(n^3)$ & $O(n)$ & $O(1)$ \\
				\hline
			\end{tabular}
			\begin{tablenotes}
				\small
				\item Примечание:  СД --- алгоритм сдвиг---деформации; РТ --- алгоритм разбрызгивания текстур; RM --- алгоритм Ray Marching; $n$ --- размер облака; $N \times M$ --- размер изображения.
			\end{tablenotes}
		\end{threeparttable}
	\end{center}
\end{table}



